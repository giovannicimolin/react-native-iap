(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[266],{3905:function(e,n,t){"use strict";t.d(n,{Zo:function(){return p},kt:function(){return d}});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=r.createContext({}),u=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=u(e.components);return r.createElement(c.Provider,{value:n},e.children)},l={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},h=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,c=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),h=u(t),d=a,m=h["".concat(c,".").concat(d)]||h[d]||l[d]||i;return t?r.createElement(m,s(s({ref:n},p),{},{components:t})):r.createElement(m,s({ref:n},p))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,s=new Array(i);s[0]=h;var o={};for(var c in n)hasOwnProperty.call(n,c)&&(o[c]=n[c]);o.originalType=e,o.mdxType="string"==typeof e?e:a,s[1]=o;for(var u=2;u<i;u++)s[u]=t[u];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}h.displayName="MDXCreateElement"},7417:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return o},metadata:function(){return c},toc:function(){return u},default:function(){return l}});var r=t(2122),a=t(9756),i=(t(7294),t(3905)),s=["components"],o={sidebar_position:2},c={unversionedId:"usage_instructions/purchase",id:"usage_instructions/purchase",isDocsHomePage:!1,title:"Making a purchase",description:"The flow of the purchase has been renewed by the founding in issue #307.",source:"@site/docs/usage_instructions/purchase.md",sourceDirName:"usage_instructions",slug:"/usage_instructions/purchase",permalink:"/react-native-iap/docs/usage_instructions/purchase",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/usage_instructions/purchase.md",version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Retrieving available items",permalink:"/react-native-iap/docs/usage_instructions/retrieve_available"},next:{title:"Restoring purchases",permalink:"/react-native-iap/docs/usage_instructions/restoring_purchases"}},u=[{value:"New Purchase Flow",id:"new-purchase-flow",children:[]},{value:"Finishing a Purchase",id:"finishing-a-purchase",children:[]}],p={toc:u};function l(e){var n=e.components,o=(0,a.Z)(e,s);return(0,i.kt)("wrapper",(0,r.Z)({},p,o,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"The flow of the ",(0,i.kt)("inlineCode",{parentName:"p"},"purchase")," has been renewed by the founding in issue ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/dooboolab/react-native-iap/issues/307"},"#307"),".\nI've decided to redesign the ",(0,i.kt)("inlineCode",{parentName:"p"},"Purchase Flow")," to not rely on ",(0,i.kt)("inlineCode",{parentName:"p"},"Promise")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Callback"),".\nThere are some reasons not to approach in this way:")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"There may be more than one response when requesting a payment."),(0,i.kt)("li",{parentName:"ol"},"Purchases are inter-session ",(0,i.kt)("inlineCode",{parentName:"li"},"asynchronuous")," meaning requests that are made may take several hours to complete and continue to exist even after the app has been closed or crashed."),(0,i.kt)("li",{parentName:"ol"},"The purchase may be pending and hard to track what has been done (",(0,i.kt)("a",{parentName:"li",href:"https://github.com/dooboolab/react-native-iap/issues/307"},"example"),"."),(0,i.kt)("li",{parentName:"ol"},"Thus the Billing Flow is an ",(0,i.kt)("inlineCode",{parentName:"li"},"event")," pattern rather than a ",(0,i.kt)("inlineCode",{parentName:"li"},"callback")," pattern.")),(0,i.kt)("p",null,"Once you have called ",(0,i.kt)("inlineCode",{parentName:"p"},"getProducts()"),", and you have a valid response, you can call ",(0,i.kt)("inlineCode",{parentName:"p"},"requestPurchase()"),". Subscribable products can be purchased just like consumable products and users can cancel subscriptions by using the iOS System Settings."),(0,i.kt)("p",null,"Before you request any purchase, you should set ",(0,i.kt)("inlineCode",{parentName:"p"},"purchaseUpdatedListener")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"react-native-iap"),". It is recommended that you start listening to updates as soon as your application launches. And don't forget that even at launch you may receive successful purchases that either completed while your app was closed or that failed to be finished, consumed or acknowledged due to network errors or bugs."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"import RNIap, {\n  purchaseErrorListener,\n  purchaseUpdatedListener,\n  type ProductPurchase,\n  type PurchaseError\n} from 'react-native-iap';\n\nclass RootComponent extends Component<*> {\n  purchaseUpdateSubscription = null\n  purchaseErrorSubscription = null\n\n  componentDidMount() {\n    RNIap.initConnection().then(() => {\n      // we make sure that \"ghost\" pending payment are removed\n      // (ghost = failed pending payment that are still marked as pending in Google's native Vending module cache)\n      RNIap.flushFailedPurchasesCachedAsPendingAndroid().catch(() => {\n        // exception can happen here if:\n        // - there are pending purchases that are still pending (we can't consume a pending purchase)\n        // in any case, you might not want to do anything special with the error\n      }).then(() => {\n        this.purchaseUpdateSubscription = purchaseUpdatedListener((purchase: InAppPurchase | SubscriptionPurchase | ProductPurchase ) => {\n          console.log('purchaseUpdatedListener', purchase);\n          const receipt = purchase.transactionReceipt;\n          if (receipt) {\n            yourAPI.deliverOrDownloadFancyInAppPurchase(purchase.transactionReceipt)\n            .then( async (deliveryResult) => {\n              if (isSuccess(deliveryResult)) {\n                // Tell the store that you have delivered what has been paid for.\n                // Failure to do this will result in the purchase being refunded on Android and\n                // the purchase event will reappear on every relaunch of the app until you succeed\n                // in doing the below. It will also be impossible for the user to purchase consumables\n                // again until you do this.\n                if (Platform.OS === 'ios') {\n                  await RNIap.finishTransactionIOS(purchase.transactionId);\n                } else if (Platform.OS === 'android') {\n                  // If consumable (can be purchased again)\n                  await RNIap.consumePurchaseAndroid(purchase.purchaseToken);\n                  // If not consumable\n                  await RNIap.acknowledgePurchaseAndroid(purchase.purchaseToken);\n                }\n\n                // From react-native-iap@4.1.0 you can simplify above `method`. Try to wrap the statement with `try` and `catch` to also grab the `error` message.\n                // If consumable (can be purchased again)\n                await RNIap.finishTransaction(purchase, true);\n                // If not consumable\n                await RNIap.finishTransaction(purchase, false);\n              } else {\n                // Retry / conclude the purchase is fraudulent, etc...\n              }\n            });\n          }\n        });\n\n        this.purchaseErrorSubscription = purchaseErrorListener((error: PurchaseError) => {\n          console.warn('purchaseErrorListener', error);\n        });\n      })\n    })\n  }\n\n  componentWillUnmount() {\n    if (this.purchaseUpdateSubscription) {\n      this.purchaseUpdateSubscription.remove();\n      this.purchaseUpdateSubscription = null;\n    }\n    if (this.purchaseErrorSubscription) {\n      this.purchaseErrorSubscription.remove();\n      this.purchaseErrorSubscription = null;\n    }\n  }\n}\n")),(0,i.kt)("p",null,"Then define the method like below and call it when user press the button."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"  requestPurchase = async (sku: string) => {\n    try {\n      await RNIap.requestPurchase(sku, false);\n    } catch (err) {\n      console.warn(err.code, err.message);\n    }\n  }\n\n  requestSubscription = async (sku: string) => {\n    try {\n      await RNIap.requestSubscription(sku);\n    } catch (err) {\n      console.warn(err.code, err.message);\n    }\n  }\n\n  render() {\n    ...\n      onPress={() => this.requestPurchase(product.productId)}\n    ...\n  }\n")),(0,i.kt)("h2",{id:"new-purchase-flow"},"New Purchase Flow"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"purchase-flow-sequence",src:t(1222).Z})),(0,i.kt)("p",null,"Most likely, you'll want to handle the \u201cstore kit flow\u201d","[",(0,i.kt)("sup",null,"[","2","]"),"][apple-store-kit-flow]",",\nwhich happens when a user successfully pays after solving a problem with his or her account \u2013 for example, when the credit card information has expired."),(0,i.kt)("p",null,"For above reason, we decided to remove ",(0,i.kt)("del",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"del"},"buyProduct"))," and use ",(0,i.kt)("inlineCode",{parentName:"p"},"requestPurchase")," instead which doesn't rely on promise function. The ",(0,i.kt)("inlineCode",{parentName:"p"},"purchaseUpdatedListener")," will receive the success purchase and ",(0,i.kt)("inlineCode",{parentName:"p"},"purchaseErrorListener")," will receive all the failure result that occured during the purchase attempt."),(0,i.kt)("h2",{id:"finishing-a-purchase"},"Finishing a Purchase"),(0,i.kt)("p",null,"Purchases will keep being emitted to your ",(0,i.kt)("inlineCode",{parentName:"p"},"purchaseUpdatedListener")," on every app relaunch until you finish the purchase."),(0,i.kt)("p",null,"Consumable purchases should be consumed by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"consumePurchaseAndroid()")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"finishTransactionIOS()"),". Once an item is consumed, it will be removed from ",(0,i.kt)("inlineCode",{parentName:"p"},"getAvailablePurchases()")," so it is up to you to record the purchase into your database before calling ",(0,i.kt)("inlineCode",{parentName:"p"},"consumePurchaseAndroid()")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"finishTransactionIOS()"),"."),(0,i.kt)("p",null,"Non-consumable purchases need to be acknowledged on Android, or they will be automatically refunded after a few days. Acknowledge a purchase when you have delivered it to your user by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"acknowledgePurchaseAndroid()"),".\nOn iOS non-consumable purchases are finished automatically but this will change in the future so it is recommended that you prepare by simply calling ",(0,i.kt)("inlineCode",{parentName:"p"},"finishTransactionIOS()")," on non-consumables as well."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"finishTransaction()")," works for both platforms and is recommended since version 4.1.0 or later. Equal to finishTransactionIOS + consumePurchaseAndroid and acknowledgePurchaseAndroid."))}l.isMDXComponent=!0},1222:function(e,n,t){"use strict";n.Z=t.p+"assets/images/react-native-iapv3-8467b005f57bac1f11896c06e15577aa.svg"}}]);